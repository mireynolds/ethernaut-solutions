#!/usr/bin/env bash
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

cd "$REPO_ROOT"

DOCKER_HOST="host.docker.internal:host-gateway"
FOUNDRY_TEST_IMAGE="foundry-build-test"
FOUNDRY_IMAGE_LATEST="ghcr.io/foundry-rs/foundry:latest"
ECDSA_TEST_IMAGE="ecdsa-build-test"
ETHERNAUT_IMAGE="ethernaut-run"
ETHERNAUT_CONTAINER="ethernaut"
ETHERNAUT_DATA_VOLUME="ethernaut-data"

LOCAL_IP="127.0.0.1"
UI_PORT="3000"

ANVIL_IP_ADDR="0.0.0.0"
ANVIL_PORT="8545"
ANVIL_STATE_PATH="/data/anvil-state.json"
ANVIL_STATE_INTERVAL="5"

DOCKER_FLAGS=(
  --cap-drop=ALL
  --security-opt="no-new-privileges=true"
  --pids-limit=512
  --memory=2g
  --cpus=2
)


usage() {
  cat <<'EOF'
Usage: 
  ./ethernaut <command>

Commands:
  launch                Runs Ethernaut app and RPC in a local docker container (also deletes existing container and volume).
  start                 Starts the Ethernaut app and RPC (if stopped).
  stop                  Stops the Ethernaut app and RPC (if running).
  delete                Deletes existing Ethernaut container and volume.
  logs                  Follow logs from the Ethernaut app and RPC.
  test                  Test the Ethernaut solutions by building a docker image.
  forge_fmt             Format tracked Solidity files using forge fmt in a docker container.
  forge_debug_level 13  Runs the level13 test with the forge debugger in a docker container.
  ecdsa                 Builds a docker image calculating ecdsa artifacts for levels 35 and 37.
  help                  Show this help.

EOF
}

build_foundry_test_image() {
  docker build -f "$REPO_ROOT/docker/$FOUNDRY_TEST_IMAGE.Dockerfile" \
    --add-host "$DOCKER_HOST" \
    -t "$FOUNDRY_TEST_IMAGE" .
}

wait_for_rpc() {
  local timeout="${1:-60}"
  local start now
  start="$(date +%s)"

  while :; do
    if docker exec "$ETHERNAUT_CONTAINER" bash -lc \
      "curl -sS -H 'content-type: application/json' --data '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"eth_chainId\",\"params\":[]}' http://${LOCAL_IP}:${ANVIL_PORT} | grep -q '\"result\"'"; then
      return 0
    fi

    now="$(date +%s)"
    if (( now - start > timeout )); then
      echo "Timed out waiting for Anvil RPC on ${LOCAL_IP}:${ANVIL_PORT}" >&2
      return 1
    fi

    sleep 1
  done
}

wait_for_addresses_log() {
  local src="/app/client/src/gamedata/deploy.local.json"
  local dst="$REPO_ROOT/addresses/addresses.log"
  local timeout="${1:-300}"
  local start now

  mkdir -p "$(dirname "$dst")"
  start="$(date +%s)"

  while :; do
    # File exists inside container, copy and return success
    if docker exec "$ETHERNAUT_CONTAINER" test -f "$src" 2>/dev/null; then
      docker cp "$ETHERNAUT_CONTAINER:$src" "$dst"
      return 0
    fi

    # Container is no longer running, return fail
    if ! docker inspect -f '{{.State.Running}}' "$ETHERNAUT_CONTAINER" 2>/dev/null | grep -q true; then
      echo "Container exited before addresses file was created" >&2
      return 1
    fi

    # Timeout
    now="$(date +%s)"
    if (( now - start > timeout )); then
      echo "Timed out waiting for addresses log" >&2
      return 1
    fi

    sleep 1
  done
}

confirm_reset() {
  echo "An existing Ethernaut environment was detected."
  echo "This will RESET the chain and delete all deployed contracts."
  read -r -p "Continue? [y/N] " reply
  case "$reply" in
    y|Y|yes|YES) return 0 ;;
    *) echo "Aborted."; return 1 ;;
  esac
}

delete() {
  # Warn if container or volume already exists
  if docker inspect "$ETHERNAUT_CONTAINER" >/dev/null 2>&1 \
     || docker volume inspect "$ETHERNAUT_DATA_VOLUME" >/dev/null 2>&1; then
    confirm_reset || return 1
  fi

  stop

  docker rm -f "$ETHERNAUT_CONTAINER" >/dev/null 2>&1 || true

  docker rmi -f "$ETHERNAUT_IMAGE" >/dev/null 2>&1 || true

  docker rmi -f "$FOUNDRY_TEST_IMAGE" >/dev/null 2>&1 || true

  docker rmi -f "$FOUNDRY_IMAGE_LATEST" >/dev/null 2>&1 || true

  docker rmi -f "$ECDSA_TEST_IMAGE" >/dev/null 2>&1 || true

  docker volume rm "$ETHERNAUT_DATA_VOLUME" >/dev/null 2>&1 || true
}

launch() {
  delete

  docker build -f "$REPO_ROOT/docker/$ETHERNAUT_IMAGE.Dockerfile" \
    -t "$ETHERNAUT_IMAGE" .
  
  docker volume create "$ETHERNAUT_DATA_VOLUME" >/dev/null 2>&1

  docker run -d \
    --name "$ETHERNAUT_CONTAINER" \
    -p "${LOCAL_IP}:${UI_PORT}:${UI_PORT}" \
    -p "${LOCAL_IP}:${ANVIL_PORT}:${ANVIL_PORT}" \
    -v "$ETHERNAUT_DATA_VOLUME":/data \
    -e ANVIL_IP_ADDR="$ANVIL_IP_ADDR" \
    -e ANVIL_PORT="$ANVIL_PORT" \
    -e ANVIL_STATE_PATH="$ANVIL_STATE_PATH" \
    -e ANVIL_STATE_INTERVAL="$ANVIL_STATE_INTERVAL" \
    "${DOCKER_FLAGS[@]}" \
    "$ETHERNAUT_IMAGE"

  wait_for_rpc

  docker exec "$ETHERNAUT_CONTAINER" bash -c 'yes | CI=true yarn deploy:contracts'

  docker exec -d "$ETHERNAUT_CONTAINER" bash -c 'yarn start:ethernaut'

  wait_for_addresses_log
}

start() {
  if ! docker inspect "$ETHERNAUT_CONTAINER" >/dev/null 2>&1; then
    echo "Container '$ETHERNAUT_CONTAINER' does not exist. Run launch." >&2
    return 1
  fi

  if docker inspect -f '{{.State.Running}}' "$ETHERNAUT_CONTAINER" 2>/dev/null | grep -q true; then
    echo "Container '$ETHERNAUT_CONTAINER' is already running." >&2
    return 1
  fi

  docker start "$ETHERNAUT_CONTAINER" >/dev/null 2>&1 || return 1

  wait_for_rpc

  docker exec -d "$ETHERNAUT_CONTAINER" bash -c 'yarn start:ethernaut'
}

stop() {
  docker stop "$ETHERNAUT_CONTAINER" >/dev/null 2>&1 || true
}

logs() {
  docker logs -f "$ETHERNAUT_CONTAINER"
}

test() {
  build_foundry_test_image
}

forge_fmt() {
  docker run --rm \
    --network=none \
    "${DOCKER_FLAGS[@]}" \
    -u "$(id -u):$(id -g)" \
    -v "$REPO_ROOT":/work:ro \
    -v "$REPO_ROOT/test":/work/test:rw \
    -w /work \
    --entrypoint bash \
    $FOUNDRY_IMAGE_LATEST \
    -c 'git ls-files -z -- "*.sol" | xargs -0 -r forge fmt'
}

forge_debug_level() {
  local level="$1"

  docker image inspect "$FOUNDRY_TEST_IMAGE" >/dev/null 2>&1 || build_foundry_test_image

  docker run --rm \
    -it \
    --add-host "$DOCKER_HOST" \
    --entrypoint /bin/bash \
    "${DOCKER_FLAGS[@]}" \
    "$FOUNDRY_TEST_IMAGE" \
    -c "forge test --debug --match-test testLevel${level} --fork-url http://host.docker.internal:8545"
}

ecdsa() {
    docker build --no-cache \
    --progress=plain \
    -f "$REPO_ROOT/docker/ecdsa-build-test.Dockerfile" \
    -t "$ECDSA_TEST_IMAGE" ./ecdsa
}

cmd="${1:-help}"
shift || true

case "$cmd" in
  launch) launch ;;
  start) start ;;
  stop) stop ;;
  delete) delete ;;
  logs) logs ;;
  test) test ;;
  forge_fmt) forge_fmt ;;
  forge_debug_level) forge_debug_level "$1" ;;
  ecdsa) ecdsa ;;
  help|-h|--help) usage ;;
  *)
    echo "Unknown command: $cmd" >&2
    echo >&2
    usage >&2
    exit 2
    ;;
esac
